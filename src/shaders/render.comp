#version 450

layout (local_size_x = 16, local_size_y = 16) in; // workgroup size todo spec constant
layout (set = 0, binding = 0, rgba8) uniform writeonly image2D renderImage; // output image
layout (set = 0, binding = 1) uniform Camera {
	mat4 viewInverse; // todo mat3?
	mat4 projInverse;
	vec4 position;
} cam;

/// Signed distance function for a sphere
/// * `point` - point in space to test for
/// * `center` - sphere center
/// * `radius` - sphere radius
float sdfSphere(vec3 point, vec3 center, float radius)
{
	return length(point - center) - radius;
} 

/// Returns a sky color for a ray miss
/// * `ray_d` - ray direction
vec3 background(const vec3 ray_d)
{
	return vec3(0.3, 0.4, 0.5) + 0.3 * ray_d.z;
}

/// Render the scene and return the color
/// * `ray_d` - ray direction
vec3 scene(const vec3 ray_o, const vec3 ray_d)
{
	return background(ray_d);
}

void main()
{
	uvec2 dim = uvec2(imageSize(renderImage)); // render image dimensions
	if (dim.x <= gl_GlobalInvocationID.x || dim.y <= gl_GlobalInvocationID.y)
		return; // don't bother rendering outside of image bounds

	vec2 pos_uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5) - vec2(dim) / 2.) / float(dim.x); // clip space position in frame
	vec4 pos_view = cam.projInverse * vec4(pos_uv.x, -pos_uv.y, 1., 1.); // view space position
	// todo normalize? divide by w? https://stackoverflow.com/questions/31686664/perspective-divide-why-use-the-w-component
	vec3 ray_d = normalize((cam.viewInverse * vec4(normalize(pos_view.xyz / pos_view.w), 0.)).xyz); // ray direction in world space

	// render scene
	vec3 color = scene(cam.position.xyz, ray_d);

	imageStore(renderImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.));
}