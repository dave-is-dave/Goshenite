[package]
name = "goshenite"
version = "0.2.1"
edition = "2021"

[features]
default = ["colored-term"]
# enables colored terminal log messages
colored-term = ["colored"]
# enables a build script to compile spirv binaries when shader source is changed
# NOTE: will add a notable increase to build times if you don't have shaderc libraries installed on your system
shader-compile = ["shaderc"]

[dependencies]
log = "0.4"
# error propogation and backtrace management
anyhow = { version = "1.0", features = ["backtrace"] }
# terminal output formatting
colored = { version = "2.0", optional = true }
# glam is a vector and math library well suited for 3D graphics (noticeably more lightweight than cgmath)
glam = { version = "0.22", features = ["debug-glam-assert"] }
# winit is a cross-platform window creation and management library (version must match vulkano-win support)
winit = "0.28"
raw-window-handle = "0.5"
# ash is a lightweight vulkan wrapper. note that with default features, the vulkan library will (attempt to) be loaded dynamically at runtime.
ash = "0.37.2"
ash-window = "0.12"
# bort has a bunch of helper structs and functions wrapped around ash
bort = { git = "https://github.com/lilly-lizard/bort/", ref = "9bf4eb3" }
# AMD vulkan memory allocator bindings
bort-vma = { git = "https://github.com/lilly-lizard/bort-vma/", ref = "bc80e6b" }
# bit-casting crate (for cpu<->gpu buffers)
bytemuck = { version = "1.7", features = ["derive"] }
# egui is a simple and fast ui library
egui = "0.21"
egui-winit = "0.21"
egui_dnd = { git = "https://github.com/lilly-lizard/egui_dnd-fork/", ref = "48a90ee" }
# hash library used by egui (fast af boii)
ahash = { version = "0.8", default-features = false, features = [
    "no-rng", # we don't need DOS-protection, so we let users opt-in to it instead
    "std",
] }
# for offset_of macro
memoffset = "0.8"

# slotmap
# specs: ECS
# rayon: parallelize iterators etc

[build-dependencies]
# used to compile spirv binaries
# NOTE: if you have shaderc libraries installed on your system, this crate will detect and use them. otherwise shaderc will be compiled.
shaderc = { version = "0.8", optional = true }

# use by doing `cargo build --profile=release-with-debug-info`
[profile.release-with-debug-info]
inherits = "release"
debug = true
